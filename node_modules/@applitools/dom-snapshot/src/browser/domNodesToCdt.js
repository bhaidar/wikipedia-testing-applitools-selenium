/* eslint-disable no-use-before-define */
'use strict';

function domNodesToCdt(docNode) {
  const NODE_TYPES = {
    ELEMENT: 1,
    TEXT: 3,
    DOCUMENT: 9,
    DOCUMENT_TYPE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
  };

  const domNodes = [
    {
      nodeType: NODE_TYPES.DOCUMENT,
    },
  ];
  domNodes[0].childNodeIndexes = childrenFactory(domNodes, docNode.childNodes);
  return domNodes;

  function childrenFactory(domNodes, elementNodes) {
    if (!elementNodes || elementNodes.length === 0) return null;

    const childIndexes = [];
    elementNodes.forEach(elementNode => {
      const index = elementNodeFactory(domNodes, elementNode);
      if (index !== null) {
        childIndexes.push(index);
      }
    });

    return childIndexes;
  }

  function elementNodeFactory(domNodes, elementNode) {
    let node, manualChildNodeIndexes;
    const {nodeType} = elementNode;
    if ([NODE_TYPES.ELEMENT, NODE_TYPES.DOCUMENT_FRAGMENT_NODE].includes(nodeType)) {
      if (elementNode.nodeName !== 'SCRIPT') {
        if (
          elementNode.nodeName === 'STYLE' &&
          elementNode.sheet &&
          elementNode.sheet.cssRules.length
        ) {
          domNodes.push({
            nodeType: NODE_TYPES.TEXT,
            nodeValue: [...elementNode.sheet.cssRules].map(rule => rule.cssText).join(''),
          });
          manualChildNodeIndexes = [domNodes.length - 1];
        }

        node = {
          nodeType: nodeType,
          nodeName: elementNode.nodeName,
          attributes: nodeAttributes(elementNode).map(key => {
            let value = elementNode.attributes[key].value;
            const name = elementNode.attributes[key].localName;

            if (/^blob:/.test(value)) {
              value = value.replace(/^blob:/, '');
            } else if (
              elementNode.nodeName === 'IFRAME' &&
              name === 'src' &&
              !elementNode.contentDocument &&
              !value.match(/^\s*data:/)
            ) {
              value = '';
            }
            return {
              name,
              value,
            };
          }),
          childNodeIndexes:
            manualChildNodeIndexes ||
            (elementNode.childNodes.length
              ? childrenFactory(domNodes, elementNode.childNodes)
              : []),
        };

        if (elementNode.shadowRoot) {
          node.shadowRootIndex = elementNodeFactory(domNodes, elementNode.shadowRoot);
        }

        if (elementNode.checked && !elementNode.attributes.checked) {
          node.attributes.push({name: 'checked', value: 'checked'});
        }
        if (
          elementNode.value !== undefined &&
          elementNode.attributes.value === undefined &&
          elementNode.tagName === 'INPUT'
        ) {
          node.attributes.push({name: 'value', value: elementNode.value});
        }
      } else {
        node = {
          nodeType: NODE_TYPES.ELEMENT,
          nodeName: 'SCRIPT',
          attributes: nodeAttributes(elementNode)
            .map(key => ({
              name: elementNode.attributes[key].localName,
              value: elementNode.attributes[key].value,
            }))
            .filter(attr => attr.name !== 'src'),
          childNodeIndexes: [],
        };
      }
    } else if (nodeType === NODE_TYPES.TEXT) {
      node = {
        nodeType: NODE_TYPES.TEXT,
        nodeValue: elementNode.nodeValue,
      };
    } else if (nodeType === NODE_TYPES.DOCUMENT_TYPE) {
      node = {
        nodeType: NODE_TYPES.DOCUMENT_TYPE,
        nodeName: elementNode.nodeName,
      };
    }

    if (node) {
      domNodes.push(node);
      return domNodes.length - 1;
    } else {
      // console.log(`Unknown nodeType: ${nodeType}`);
      return null;
    }

    function nodeAttributes({attributes = {}}) {
      return Object.keys(attributes).filter(k => attributes[k].localName);
    }
  }
}

module.exports = domNodesToCdt;
module.exports.NODE_TYPES = {
  ELEMENT: 1,
  TEXT: 3,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
};
